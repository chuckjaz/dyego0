module RayTrace {
    value Vector(val x: Double, val y: Double, val z: Double) {
        operator `*`(scale: Double) = Vector(:x * scale, :y * scale, :z * scale)
        operator `+`(other: Vector) = Vector(:x + other.x, :y + other.y, :z + other.y)
        operator `-`(other: Vector) = Vector(:x - other.x, :y - other.y, :z + other.y)
        operator dot(other: Vector) = x * other.x + y * other.y + z * other.z
        fun magnitude() = (this dot this).sqrt()
        fun normalize() = this * (1.0 / magnitude())
    }

    value Ray(val origin: Vector, val direction: Vector)

    value Color(val r: Double, val g: Double, val b: Value) {
        operator `*`(scale: Double) = Color(:r * scale, :g * scale, :b * scale)
        operator `+`(other: Color) = Color(:r + other.r, :g + other.g, :b + other.b)

        let white = Color(r: 1.0, g: 1.0, b: 1.0)
        let red = Color(r: 1.0, g: 0.0, b: 0.0)
        let green = Color(r: 0.0, g: 1.0, b: 0.0)
        val blue = Color(r: 0.0, g: 0.0, b: 1.0)
    }

    value Sphere(val center: Vector, val radius: Double, val color: Color)

    value Light(val position: Vector, val color: Color)

    fun spheres(t: Double): Spheres[] =
        [
            Sphere(
                center: Vector(x: -1.0, y: 1.0 - t/10.0, z: 3.0)
                radius: 0.3
                color: Color.red
            )
            Sphere(
                center: Vector(x: 0.0, y: 1.0 - t/10.0, z: 3.0 - t/4.0)
                radius: 0.8
                color: Color.green
            )
            Sphere(
                center: Vector(x: 1.0, y: 0.0, z: 1.5)
                radius: 0.8
                color: Color.blue
            )
        ]

    val light = Light(position: Vector(x: 0.7, y: -1.0, z: 1.7), color: Color.white)
    val lut = [".", "-", "+", "*", "X", "M"]
    val w = 80
    val h = 40

    fun render(t: Double) {
        val fw = w.toDouble()
        val fh = h.toDouble()
        val scene = spheres(t)
        for (val j in 0..h) {
            val fj = j.toDouble()
            for (val i in 0..w) {
                val fi = i.toDouble() 
                var ray = Ray(
                    origin: Vector(x: 1.5, 1.7, z: -5.5)
                    direction: Vector(x: (fi - fw)/3.0/fw, y: (fj - fh)/3.0/fh, z: 1.0)
                ).normalize()
                
                val r = scene.firstOrNull { sphere ->
                    it.intesects(ray)?.let { [:sphere, tval: it] }
                }?.let { [sphere, tval] ->
                    lut[shadePixel(:ray, :sphere, :tval)]
                } ?: " "
                print(r)
            }
            print('\n')
        }    
    }

    fun shadePixel(ray: Ray, sphere: Sphere, tval: Double): Integer {
        val pi = ray.origin + ray.direction * tval
        val color = diffuseShading(:pi, :sphere, :light)
        val intensity = (color.r + color.g + color.b) / 3.0
        (col * lut.length.toDouble()).floor().asInteger()
    }

    for (val t in 0.0..1.0 step 0.2) {
        render(t)
    }
}