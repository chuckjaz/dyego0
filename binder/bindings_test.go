package binder_test

import (
	"dyego0/binder"
	"dyego0/types"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe("bindings", func() {
	open := func() types.TypeSymbol {
		return types.NewTypeSymbol("", nil)
	}
	nb := func() binder.Bindings {
		return binder.NewBindings()
	}
	int := func() types.TypeSymbol {
		r := types.NewTypeSymbol("Int", nil)
		types.NewType(r, types.Record, nil, nil, nil, nil, nil, nil)
		return r
	}
	It("can create a bindings", func() {
		b := binder.NewBindings()
		Expect(b).To(Not(BeNil()))
	})
	It("can unify open types", func() {
		b := nb()
		t := open()
		v := open()
		result := b.UnifyType(t, v)
		Expect(result).To(BeTrue())
	})
	It("can bind a type to a variable, left", func() {
		b := nb()
		t := open()
		v := int()
		result := b.UnifyType(t, v)
		Expect(result).To(BeTrue())
		Expect(t.Type()).To(Equal(v.Type()))
		Expect(t.Canonical().Name()).To(Equal("Int"))
	})
	It("can bind a type to a variable, right", func() {
		b := nb()
		t := int()
		v := open()
		result := b.UnifyType(t, v)
		Expect(result).To(BeTrue())
		Expect(v.Type()).To(Equal(t.Type()))
		Expect(v.Canonical().Name()).To(Equal("Int"))
	})
	It("can bind two together then bind all to type", func() {
		b := nb()
		one := open()
		two := open()
		i := int()
		result := b.UnifyType(one, two)
		Expect(result).To(BeTrue())
		result = b.UnifyType(one, i)
		Expect(result).To(BeTrue())
		Expect(one.Type()).To(Equal(i.Type()))
		Expect(two.Type()).To(Equal(i.Type()))
	})
	It("It can bind two groups of two and unify all together", func() {
		b := nb()
		one := open()
		two := open()
		three := open()
		four := open()
		i := int()
		result := b.UnifyType(one, two)
		Expect(result).To(BeTrue())
		result = b.UnifyType(three, four)
		Expect(result).To(BeTrue())
		result = b.UnifyType(four, two)
		Expect(result).To(BeTrue())
		result = b.UnifyType(four, i)
		Expect(result).To(BeTrue())
		Expect(one.Type()).To(Equal(i.Type()))
		Expect(two.Type()).To(Equal(i.Type()))
		Expect(three.Type()).To(Equal(i.Type()))
		Expect(four.Type()).To(Equal(i.Type()))
	})
	It("It can bind two groups of two and unify all together, backwards", func() {
		b := nb()
		one := open()
		two := open()
		three := open()
		four := open()
		i := int()
		result := b.UnifyType(one, two)
		Expect(result).To(BeTrue())
		result = b.UnifyType(three, four)
		Expect(result).To(BeTrue())
		result = b.UnifyType(two, four)
		Expect(result).To(BeTrue())
		result = b.UnifyType(four, i)
		Expect(result).To(BeTrue())
		Expect(one.Type()).To(Equal(i.Type()))
		Expect(two.Type()).To(Equal(i.Type()))
		Expect(three.Type()).To(Equal(i.Type()))
		Expect(four.Type()).To(Equal(i.Type()))
	})
	It("should bind an open reference type", func() {
		b := nb()
		one := open()
		i := int()
		refOne := types.MakeReference(one)
		refI := types.MakeReference(i)
		result := b.UnifyType(refOne, refI)
		Expect(result).To(BeTrue())
		Expect(one.Type()).To(Equal(i.Type()))
	})
	It("should bind an open array type", func() {
		b := nb()
		one := open()
		i := int()
		arrOne := types.MakeArray(one)
		arrI := types.MakeArray(i)
		result := b.UnifyType(arrOne, arrI)
		Expect(result).To(BeTrue())
		Expect(one.Type()).To(Equal(i.Type()))
	})
	It("should unify to itself as a noop", func() {
		b := nb()
		one := open()
		result := b.UnifyType(one, one)
		Expect(result).To(BeTrue())
	})
	It("should be unify the same variables twice as a noop", func() {
		b := nb()
		one := open()
		two := open()
		result := b.UnifyType(one, two)
		Expect(result).To(BeTrue())
		result = b.UnifyType(one, two)
		Expect(result).To(BeTrue())
	})
	It("should be able to unify a bound type to itself", func() {
		b := nb()
		i := int()
		result := b.UnifyType(i, i)
		Expect(result).To(BeTrue())
	})
	It("should not unify different types", func() {
		b := nb()
		i1 := int()
		i2 := int()
		result := b.UnifyType(i1, i2)
		Expect(result).To(BeFalse())
	})
	It("should not be able to unify a open types to different types", func() {
		b := nb()
		i1 := int()
		i2 := int()
		one := open()
		two := open()
		result := b.UnifyType(one, i1)
		Expect(result).To(BeTrue())
		result = b.UnifyType(two, i2)
		Expect(result).To(BeTrue())
		result = b.UnifyType(one, two)
		Expect(result).To(BeFalse())
	})
})
